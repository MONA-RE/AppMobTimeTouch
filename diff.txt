<?php
// Corrections à apporter dans timeclockrecord.class.php

// CORRECTION 1: Améliorer la méthode calculateWorkDuration()
// Remplacer la méthode existante par cette version corrigée

/**
 * Calculate work duration based on clock in/out times and breaks
 *
 * @return int Work duration in minutes
 */
public function calculateWorkDuration()
{
    // Vérifier que les heures de début et fin sont définies
    if (empty($this->clock_in_time) || empty($this->clock_out_time)) {
        $this->work_duration = null;
        dol_syslog("TimeclockRecord::calculateWorkDuration - Missing clock_in_time or clock_out_time", LOG_WARNING);
        return 0;
    }

    try {
        // Conversion sécurisée des timestamps
        $clock_in = $this->convertToTimestamp($this->clock_in_time);
        $clock_out = $this->convertToTimestamp($this->clock_out_time);
        
        // Validation que les conversions ont réussi
        if ($clock_in === false || $clock_out === false) {
            $this->work_duration = null;
            dol_syslog("TimeclockRecord::calculateWorkDuration - Failed to convert timestamps", LOG_ERROR);
            return 0;
        }
        
        // Validation que clock_out est après clock_in
        if ($clock_out <= $clock_in) {
            $this->work_duration = 0;
            dol_syslog("TimeclockRecord::calculateWorkDuration - Clock out time is before or equal to clock in time", LOG_WARNING);
            return 0;
        }
        
        // Calcul de la durée totale en minutes
        $total_minutes = ($clock_out - $clock_in) / 60;
        
        // Validation et conversion du break_duration
        $break_duration = 0;
        if (!empty($this->break_duration)) {
            if (is_numeric($this->break_duration)) {
                $break_duration = (int) $this->break_duration;
            } else {
                dol_syslog("TimeclockRecord::calculateWorkDuration - Invalid break_duration: " . $this->break_duration, LOG_WARNING);
            }
        }
        
        // Calcul de la durée de travail effective
        $work_minutes = $total_minutes - $break_duration;
        
        // S'assurer que la durée n'est pas négative
        $this->work_duration = max(0, round($work_minutes));
        
        dol_syslog("TimeclockRecord::calculateWorkDuration - Calculated work duration: " . $this->work_duration . " minutes", LOG_DEBUG);
        
        return $this->work_duration;
        
    } catch (Exception $e) {
        dol_syslog("TimeclockRecord::calculateWorkDuration - Exception: " . $e->getMessage(), LOG_ERROR);
        $this->work_duration = null;
        return 0;
    }
}

// CORRECTION 2: Nouvelle méthode utilitaire pour la conversion sécurisée des timestamps
// Ajouter cette nouvelle méthode dans la classe

/**
 * Convert various timestamp formats to Unix timestamp
 *
 * @param mixed $datetime DateTime value (string, timestamp, or database format)
 * @return int|false Unix timestamp or false on failure
 */
private function convertToTimestamp($datetime)
{
    if (empty($datetime)) {
        return false;
    }
    
    // Si c'est déjà un timestamp numérique valide
    if (is_numeric($datetime)) {
        $timestamp = (int) $datetime;
        // Vérifier que c'est un timestamp raisonnable (après 2000, avant 2100)
        if ($timestamp > 946684800 && $timestamp < 4102444800) {
            return $timestamp;
        }
    }
    
    // Si c'est une chaîne, essayer la conversion via jdate
    if (is_string($datetime)) {
        try {
            // Utiliser la méthode jdate de Dolibarr
            $timestamp = $this->db->jdate($datetime);
            
            // Validation du résultat
            if (is_numeric($timestamp)) {
                $timestamp = (int) $timestamp;
                if ($timestamp > 946684800 && $timestamp < 4102444800) {
                    return $timestamp;
                }
            }
            
            // Fallback: essayer strtotime si jdate échoue
            $timestamp = strtotime($datetime);
            if ($timestamp !== false && $timestamp > 946684800 && $timestamp < 4102444800) {
                return $timestamp;
            }
            
        } catch (Exception $e) {
            dol_syslog("TimeclockRecord::convertToTimestamp - Exception converting datetime: " . $e->getMessage(), LOG_ERROR);
        }
    }
    
    dol_syslog("TimeclockRecord::convertToTimestamp - Failed to convert datetime: " . print_r($datetime, true), LOG_ERROR);
    return false;
}

// CORRECTION 3: Améliorer la méthode clockOut()
// Remplacer la partie concernée dans la méthode clockOut existante

/**
 * Clock out a user
 *
 * @param User   $user      User object
 * @param string $location  Location
 * @param float  $latitude  Latitude
 * @param float  $longitude Longitude
 * @param string $note      Note
 * @return int              <0 if KO, >0 if OK
 */
public function clockOut($user, $location = '', $latitude = null, $longitude = null, $note = '')
{
    // Get active record
    $active_record_id = $this->getActiveRecord($user->id);
    if ($active_record_id <= 0) {
        $this->error = 'NoActiveClock';
        return -1;
    }

    if ($this->fetch($active_record_id) <= 0) {
        return -1;
    }

    $now = dol_now();

    // Update record with modification info
    $this->fk_user_modif = $user->id;
    
    // CORRECTION: S'assurer que clock_out_time est au bon format pour la base
    $this->clock_out_time = $this->db->idate($now);
    
    $this->status = self::STATUS_COMPLETED;
    $this->location_out = $location;
    $this->latitude_out = $latitude;
    $this->longitude_out = $longitude;
    $this->ip_address_out = getUserRemoteIP();

    // Handle note properly
    if (!empty($note)) {
        $this->note_public .= (!empty($this->note_public) ? "\n" : '') . $note;
    }

    // CORRECTION: Validation avant le calcul de durée
    dol_syslog("TimeclockRecord::clockOut - Before calculateWorkDuration - clock_in_time: " . $this->clock_in_time . ", clock_out_time: " . $this->clock_out_time, LOG_DEBUG);
    
    // Calculate work duration avec gestion d'erreur
    $duration_result = $this->calculateWorkDuration();
    
    if ($duration_result === false) {
        dol_syslog("TimeclockRecord::clockOut - Failed to calculate work duration", LOG_ERROR);
        // Ne pas bloquer le clock out, mais signaler le problème
        $this->work_duration = 0;
    }

    $update_result = $this->update($user);
    
    if ($update_result > 0) {
        dol_syslog("TimeclockRecord::clockOut - Successfully clocked out user " . $user->id . " with work duration: " . $this->work_duration . " minutes", LOG_INFO);
    }
    
    return $update_result;
}

// CORRECTION 4: Améliorer la méthode clockIn() pour la cohérence
// Ajouter cette validation dans clockIn() aussi

/**
 * Clock in a user (version corrigée)
 */
public function clockIn($user, $timeclock_type_id = 1, $location = '', $latitude = null, $longitude = null, $note = '')
{
    global $conf;

    // Check if user already has an active record
    $active_record = $this->getActiveRecord($user->id);
    if ($active_record > 0) {
        $this->error = 'UserAlreadyClockedIn';
        return -1;
    }

    $now = dol_now();

    // Initialize record with all required fields
    $this->fk_user = $user->id;
    $this->fk_user_creat = $user->id;
    $this->entity = $conf->entity;
    $this->datec = $this->db->idate($now);
    
    // CORRECTION: S'assurer que clock_in_time est au bon format
    $this->clock_in_time = $this->db->idate($now);
    
    $this->fk_timeclock_type = $timeclock_type_id;
    $this->status = self::STATUS_IN_PROGRESS;
    $this->location_in = $location;
    $this->latitude_in = $latitude;
    $this->longitude_in = $longitude;
    $this->ip_address_in = getUserRemoteIP();
    $this->note_public = $note;
    $this->break_duration = 0;

    // Auto-generate reference if not set
    if (empty($this->ref)) {
        $this->ref = '(PROV)';
    }

    dol_syslog("TimeclockRecord::clockIn - Clocking in user " . $user->id . " at " . $this->clock_in_time, LOG_INFO);

    $result = $this->create($user);

    if ($result > 0) {
        return $this->id;
    } else {
        dol_syslog("TimeclockRecord::clockIn - Failed to create record: " . $this->error, LOG_ERROR);
        return $result;
    }
}

// CORRECTION 5: Méthode utilitaire pour debugging
// Ajouter cette méthode pour aider au debugging

/**
 * Debug method to check timestamp values
 *
 * @return array Debug information
 */
public function getTimestampDebugInfo()
{
    $debug_info = array();
    
    $debug_info['clock_in_time_raw'] = $this->clock_in_time;
    $debug_info['clock_out_time_raw'] = $this->clock_out_time;
    $debug_info['break_duration_raw'] = $this->break_duration;
    
    if (!empty($this->clock_in_time)) {
        $debug_info['clock_in_converted'] = $this->convertToTimestamp($this->clock_in_time);
        $debug_info['clock_in_type'] = gettype($this->clock_in_time);
    }
    
    if (!empty($this->clock_out_time)) {
        $debug_info['clock_out_converted'] = $this->convertToTimestamp($this->clock_out_time);
        $debug_info['clock_out_type'] = gettype($this->clock_out_time);
    }
    
    if (!empty($this->break_duration)) {
        $debug_info['break_duration_type'] = gettype($this->break_duration);
        $debug_info['break_duration_numeric'] = is_numeric($this->break_duration);
    }
    
    return $debug_info;
}